# Skillsync

## Getting Started
First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

## Tools
1. Framework: Next.js (App Router) – fullstack-friendly, fast routing, React-based
2. Styling: Tailwind CSS – fast, utility-first UI building
3. UI Components: ShadCN UI or Radix UI – accessible, customizable
4. State Management: Zustand or Jotai – simple and scalable
5. Animations: Framer Motion – smooth transitions for UI polish
6. API Layer: tRPC – type-safe, fast API dev with zero boilerplate
7. Backend Platform: Supabase – auth + PostgreSQL + storage + serverless functions
8. LLM API: OpenAI SDK – explanation scoring, challenge generation, suggestions
9. Graph/Skill Trees: D3.js – powerful for building interactive skill trees
10. Embeddings / Vector Search: Supabase Vector (Postgres extension)

## Phase 1  
1. user can add skills i.e: golang, java, leadership
2. user can add sub skill for root skill, i.e: user clicks plus button on a skill to add a subskill
3. user can mark the skill as (Want to Learn / Learning / Proficient / Mastered)
4. user input some basic information like years of work experience, current role
### Required Tools
- **Next.js** – app structure, routing  
- **Tailwind CSS** – fast UI building  
- **ShadCN UI** – skill cards, modals, dropdowns  
- **Zustand** – local state for skill trees/UI  
- **tRPC** – API between frontend and DB  
- **Supabase** – auth, user profile, skill table  
- **Framer Motion** – smooth transitions (e.g. adding subskill) 


## Phase 2
1. self assessment skill checklist, example for docker: [x]Build Dockerfile from scratch [x]Use multi-stage builds []Optimize for performance
2. ask user to teach it “Explain goroutines and when to use mutex vs channel.” then we score based on Clarity, Coverage, Depth, Misconceptions
3. skill consistency checks like "You know Kubernetes but don’t know Docker?"
4. analyze the missing skills from root skill. We need to research of how we discover the missing skill
### Required Tools
- **All Phase 1 tools**  
- **OpenAI SDK** – explanation scoring with LLM  
- **Supabase Vector** – store embeddings of user answers or concepts  
- **Custom logic in tRPC** – for skill consistency heuristics  


## Phase 3 
1. lets says your skill is golang, conccurency, image processing. we can add relation to the skill like conccurency
   can be used to make image processing faster.
2. showing suggestion like, recommended to learn this before move to next one

### Required Tools
- **All Phase 2 tools**  
- **PostgreSQL with edge tables** – skill relationships  
- **D3.js** – visualizing skill relationships  
- **Optional: OpenAI SDK** – to infer related skills or next steps  


## Phase 4
1. skills tree generated by expert like 10 years experience in marketing, we can compare our skills and find whats missing
2. mini challenges like “You say you know Golang concurrency — here’s a challenge.”
### Required Tools
- **All Phase 3 tools**  
- **D3.js** – compare skill trees visually  
- **OpenAI SDK** – generate contextual skill challenges  


## Next big things
1. Temporal Skill Drift: Detect skills getting stale over time (e.g. jQuery, SVN)
2. Auto-generated Roadmaps: Given a goal (e.g. “Become SRE”), map ideal skill path
3. “Prove It” Mode: Upload code/portfolio and link to skills auto-tagged by LLM
4. Team Skill Matrix: Extend for orgs—map gaps and dependencies across teams
### Required Tools
- **All Phase 4 tools**  
- **OpenAI SDK** – roadmap generation, skill tagging  
- **Supabase Storage** – handle code uploads  
- **Scheduled Functions** – detect outdated skills  
- **D3.js** – visualize team skill graphs or heatmaps  
